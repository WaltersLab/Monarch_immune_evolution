---
title: "Monarch Immunity Reboot Permutations -- CURATED"
author: "Jamie Walters"
date: "Mar 01, 2021"
output:
    html_document:
        theme: readable
        highlight: haddock
---
> Rerunning this analysis, but applying filtering to remove outliers where dN/dS or pN/pS > 1.5. Previously we used 1.0, but this arguably a bit too convservative.  I'm also explicitly removing the two effectors with high Taj D and the one modulator with a flawed gene model.

```{r}
usefilter <- TRUE  # flag to cause filtering
filttext <- ifelse(usefilter,"-FILTERED", "-ORIGINAL") # for filenaming
maxval <- 1.5  # maximum value to allow for dN/dS or pN/pS
datenow <- "_2021-03-01"
n.perms <- 10000  # how many permutations to run
```


This document records Jamie's efforts to perform the paired-control bootstrapping analysis we've devised for assessing immune gene evolution. As this will document, there are some notable differences in the numbers of genes analyzed here relative to the original effort, due to filtering (quite reasonably) applied by Venkat.

Step one is to read in the sets of control genes for each immune gene generated by Wen-Hao. I'm taking these from the github repo originally posted in the paper. 

There were originally 102 immune genes, and each had at least 8 controls.

```{r}
 #Read Wen-Hao's files
control_dir <- "../biorxiv_version1/Paired-control_analyses/2_Select_controls_and_run_permutations/Outputs/Selected_control_gene_lists/"
PairedFiles <- list.files(path = control_dir)
length(PairedFiles)  # 102
PairedFilesID <- gsub(x = PairedFiles, pattern = "control_gene_list_for_(DPOGS\\d+).txt", replacement = "\\1", perl = T)

readControls <- function(iGene) {
	myCtls <- readLines(paste0(control_dir,PairedFiles[iGene]))  # read file into char vector
	# The control set in each file apparently includes the target immune gene (!?)
	myCtls <- myCtls[ myCtls != PairedFilesID[iGene]] # remove the target gene from control set
	return(myCtls)
}

# Generate a list of control genes for each target immune gene.
controls <- list() 
for (i in seq_along(PairedFilesID)) {
	controls[[PairedFilesID[i]]] <- readControls(i)
}

```

Now read in the data table from Venkat of popgen parameters per gene. (I tweaked the spelling of the function and type labels, hence the "_edit.csv" relative to the original)

Of note, this table has several redundant entries, because the same gene was used as a control for different immune genes, even in different functional classes. In the paired-control approach, we don't need to know what "class" the controls belong to, only which immune gene they correspond to as control, so the "class" data ends up being superfluous in this analysis.

Also, only 95 of the original 102 immune genes passed filtering.

```{r}
# Read Table from Venkat
genestats <- read.csv(file = "Immune_genes_final_DB_edit.csv", as.is = T)
genestats <- genestats[-1] # don't need column of row numbers
length(genestats$Gene_ID)
length(unique(genestats$Gene_ID))
genestats <- genestats[ !duplicated(genestats$Gene_ID), ] # remove redundant rows (some control genes are used for multiple immune genes, so were multiply listed in Venkat's table, though at times with different "function")

########### FILTERING
if (usefilter) {
    genestats <- genestats[ genestats$W_Danaus_plexippus_East < maxval & genestats$East_Pin_Pis_Monarch < maxval, ]
}
########### 

########### CURATING
# Manual inspection suggests 3 genes are problematic and should be removed.
# DPOGS215182 modulator that has flawed gene model
# DPOGS213997 & DPOGS210303, effectors that have excessive TajD
# DPOGS209810 is the one Signaling gene that is an outlier.
problem.genes <- c("DPOGS215182", "DPOGS213997", "DPOGS210303") #, "DPOGS209810")
genestats <- genestats[ ! genestats$Gene_ID %in% problem.genes , ]
########### 


table(genestats$Gene_Type)  # 95 immune genes
table(genestats$Gene_Type, genestats$Gene_function)
```

A further important question is, how many control genes did we lose for each immune gene due to the filtering applied? It turns out that a notable number of controls were excluded, and some immune genes end up with few or no control genes. 


```{r, fig.width = 8, fig.height=4}
# now remove igenes & controls that don't have data.
# First, extract ID for genes with data
igenesDat <- genestats$Gene_ID[genestats$Gene_Type == "Immune_genes"] # 95 genes
controlDat <- genestats$Gene_ID[genestats$Gene_Type == "Paired_control"] 
# make list of control genes with available data
contFilt <- lapply(controls, function(x) { x[ x %in% controlDat ] } )

controlsCount <- sapply(controls, length)
contFiltCount <- sapply(contFilt, length)

par(mfrow = c(1,2))
hist(contFiltCount, breaks = seq(0,max(contFiltCount)+1, 1), main = "Remaining control genes per immune gene", cex.main = 0.8)
hist(contFiltCount, breaks = seq(0,max(contFiltCount)+1, 1), xlim = c(0,15), main = "Remaining control genes per immune gene", sub="Zoomed to low counts", cex.main = .8)


geneloss <- controlsCount-contFiltCount
plot(contFiltCount~controlsCount, pch = 19, cex = 0.4, xlim=c(0,450), ylim=c(0,450), xlab = "Original Control Count", ylab = "Filtered Control Count" )
abline(a = 0, b = 1, lty = 2, col = "blue")
hist(geneloss, xlab = "Number of control genes lost", ylab = "Count of Immune Gene", main="Distribution of Gene Loss", cex.main = 0.7)
```


However, strikingly, they are already among the 7 immune genes already filtered out by Venkat's criteria. They are not present in the dataframe of popgen stats from Venkat. So we don't lose many more immune genes due to this loss of control genes.

```{r}
# We can't use immune genes that have too few controls, or none.
minctl <- 6 # set minimum number of control genes.
igeneSansCtl <- names(contFiltCount[contFiltCount < minctl])
controlsCount[igeneSansCtl]  # these are the counts of control genes. first 3 are <250 bp, last is ~1.3kb.
sum(genestats$Gene_ID %in% igeneSansCtl)
```

So now we have a consolidated set of immune and control genes with corresponding popgen data, and we can proceed to implement the permutation test as described in the manuscript:

> For a given immune functional group, we calculated the test statistic as the summation of the difference between an immune gene and the mean of its control genes. We determined significance through 10,000 permutations. For each permutation round, we randomly sampled one gene for each immune gene from a pool containing the immune gene itself and all corresponding control genes with replacement to serve as the test gene, and calculate the difference between the test gene and the mean of the remaining genes in the pool. The permuted test statistic is calculated as the summation of those differences for genes belonging to a given immune functional group. We calculated P-values as the percentage of the 10,000 permutations in which the absolute value of the test statistic (observed value) is less than the absolute mean value of the permuted sets (permuted null distribution)

My approach to implementing this was built on four nested functions:

1) func1 : take a set of genes, calculate the mean values for each param.
2) func2 : calculate the difference between target gene & mean values of control set. Include option to permute target & controls. 
3) func3 : Calculate test-statstics for a set of "target" genes, sum differences with mean(controls) for each gene.
4) func4 : Generate N permutations of test-statistcs


```{r}

func1_means <- function( refgenes, statDF = genestats, selectCols = NULL, removeNA = TRUE ) {  #ref genes are "controls"
	# use `selectCols` to determine which columns should be returned. 
	if (is.null(selectCols)) {
		selectCols <- unlist(lapply(statDF, is.numeric))
	}
	refgenesDF <- statDF[ statDF$Gene_ID %in% refgenes, selectCols]  # subset to get values for reference genes
	refgenesmu <- colMeans(refgenesDF, na.rm = removeNA)
	return(refgenesmu)
}

# An example of using it on a vector of control genes
func1_means(refgenes = contFilt[[4]])
```


Func2 takes a target immune gene and calculates the differences in stats with the mean of controls. Importantly, the function has the option to permute immune and control genes, so result is randomized.
```{r}
func2_diff <- function(imGene, ctlList = contFilt, statDF = genestats, selectCols = NULL, permute = FALSE ) {
	# use `selectCols` to determine which columns should be returned, consistent with func1_means()
	if (is.null(selectCols)) {
		selectCols <- unlist(lapply(statDF, is.numeric))
	}
	
	if (permute) { 
		geneset <- sample(c(imGene,ctlList[[imGene]])) # permute immune gene w/ controls
		target <- geneset[1] # define random "target"
		ctls <- geneset[-1] # define random "controls"
	} else {  # use unpermuted data values
		target <- imGene
		ctls   <- ctlList[[imGene]]
	} 
	target_vals <- unlist(statDF[ statDF$Gene_ID == target,selectCols])  # select values for target gene, need `unlist()` because it is a row, so is not vector
	ctl_vals <- func1_means( refgenes = ctls, statDF = statDF, selectCols = selectCols) # calc mean values for control
	diff_vals <- target_vals - ctl_vals
	return(diff_vals)
}


# Example of generating a difference in target vs mean(control), with and without permutation
func2_diff(imGene = "DPOGS200349", permute = F)
func2_diff(imGene = "DPOGS200349", permute = T)
```

Func3 takes a "set" of genes, calculates the difference between target and controls for each, and then sums those differences for a single observation for all genes. In other words, this calculates the "test statistic" we are using: the sum across target genes of target gene - mean of controls.
```{r}

func3_set <- function(imGeneSet, ctlList = contFilt, statDF = genestats, selectCols = NULL, permute = FALSE) {
	diffmtx <- sapply(imGeneSet, FUN = function(x) {func2_diff(imGene = x, ctlList = ctlList, statDF = statDF, selectCols = selectCols, permute = permute)}) 
	return(colSums(t(diffmtx), na.rm=T))
	#return(diffmtx)
}

func3_set(imGeneSet = names(contFilt[20:24]), permute = F )

```

Func4 gives a dataframe of permuted test statistics for a given gene set. And we need a function for getting the p-values. 
```{r}

# Function to generate a DF of permuted values of the test statistic
func4_perms <- function(imGeneSet, Nperms = 100, ctlList = contFilt, statDF = genestats, selectCols = NULL) {
	permsList <- lapply(1:Nperms, function(n) {func3_set(imGeneSet = imGeneSet, permute = T, ctlList = ctlList, statDF = statDF, selectCols = selectCols)})  # use lapply to generate Nperms permutations, so mclapply could later be used to parallelize if need be.
	permsDF <- do.call(rbind, permsList)
	return(as.data.frame(permsDF))
}

# Calculate pvalue given test-stat and null distribution.
permuteP <- function(random, observed, naOmit=F) {
	#if desired, check for NAs and fail if present
	if (naOmit == F) {
		if (sum(is.na(random)) > 0 ) {
			stop("NAs present in null distribution")
		}
	}
	if (naOmit == T) {
		random <- na.omit(random) 	
	}
	P <- mean(abs(random) > abs(observed))
	return(P)
}


```

Now we can proceed with actually doing the work...

```{r}
# make sets of immune genes for each class
imGeneClassList <- split(x = genestats$Gene_ID[genestats$Gene_Type == "Immune_genes"], f = genestats$Gene_function[genestats$Gene_Type == "Immune_genes"])

# Also need to analyze all immune genes collectively
imGeneClassList[["All Immune"]] <- genestats$Gene_ID[genestats$Gene_Type == "Immune_genes"]
imGeneClassList <- imGeneClassList[c(5,3,2,4,1)] # Rearrange to match rough order of biological function


imGeneValues <- lapply(imGeneClassList, func3_set) # test statistics for each popgen stat for each class

set.seed(4321)
permuteValues <- lapply(imGeneClassList, func4_perms, Nperms = n.perms) # generate permuted nulls for each class

# calculate P-values for each statistic in each gene group.
pvalues <- vector(mode = "list", length = length(imGeneValues))
names(pvalues) <- names(imGeneValues)
for (class in names(pvalues)) {
	pvalues[[class]] <- sapply(names(imGeneValues[[class]]),  function(x) { 
				permuteP( random = permuteValues[[class]][[x]], observed = imGeneValues[[class]][[x]], naOmit = T)
						})
}
```

And save an image of the workspace in order to later work with results without rerunning permutations.

```{r}
image.name <- paste0("image",datenow,filttext,".Rdata")
save.image(file = image.name)
```


Added Oct 11, 2020: We need to output point estimates for immune genes. The above analysis doesn't generate those, so I need to explicitly calculate them for tabulating in paper.

```{r}

getSummaryStats <- function( refgenes, statDF = genestats, selectCols = NULL, removeNA = TRUE ) {  #ref genes are "controls"
	# use `selectCols` to determine which columns should be returned. 
	if (is.null(selectCols)) {
		selectCols <- unlist(lapply(statDF, is.numeric))
	}
	refgenesDF <- statDF[ statDF$Gene_ID %in% refgenes, selectCols]  # subset to get values for reference genes
	# statsOut <- sapply(refgenesDF, summary)
	refgenesmu <- colMeans(refgenesDF, na.rm = removeNA)
	refgenessd <- apply( refgenesDF, MAR = 2, FUN = sd, na.rm = removeNA)
	return(cbind("mean" = refgenesmu, "stdev" =refgenessd))
}

# getSummaryStats(imGeneClassList[[2]])  # test code for function

imGenePointEst <- lapply(imGeneClassList, function(x) {getSummaryStats(refgenes = x) } )

```


Write results out to file.
```{r, warning=FALSE}

outdataList <- vector(mode = "list", length = length(imGeneValues))
names(outdataList) <- names(pvalues)
#Write results to file

outfile <- paste0("Results",datenow,filttext,"_markdown.txt")
cat("Immune Gene Paired-Control Results\n", file = outfile)
if(usefilter) {cat(paste("Filtered for dN/dS & pN/pS below", maxval), file = outfile, append=T)}
for (class in names(pvalues)){
	cat("\n\n",class, "\n", sep="", file = outfile, append = T)
	outdataList[[class]] <- cbind(imGeneValues[[class]], pvalues[[class]])
	colnames(outdataList[[class]]) <- c("TestStat", "P_value")
	write.table(round(outdataList[[class]], 5), outfile, append = T, quote = F, sep = "\t", col.names = NA)
}

# combing data for formatting output tables

rownames.proper <- c("Pi_0-fold", "Tajima's D_0-fold", "Watterson's theta_0-fold", 
                     "Pi_4-fold", "Tajima's D_4-fold", "Watterson's theta_4-fold",
                     "Pi_gene", "Tajima's D_gene", "Watterson's theta_gene",
                     "DoS", "dN/dS", "Pi.N/Pi.S", "Alpha", "Omega-alpha"
                     )

formatList <- vector(mode = "list", length = length(imGeneValues))
names(formatList) <- names(pvalues)
for (class in names(pvalues)) {
    formatList[[class]] <- data.frame(cbind(imGenePointEst[[class]], imGeneValues[[class]], pvalues[[class]]))
    names(formatList[[class]])[3:4] <- c("TestStat", "P_value")
    formatList[[class]] <- round(formatList[[class]], 5)
    formatList[[class]]["direction"] <- ifelse(formatList[[class]][["TestStat"]] > 0, "Greater", "Lesser")
    row.names(formatList[[class]]) <- rownames.proper
}


formatTable <- function(param = "Pi_0-fold") {
    # extract param-associated values from each immune class into list
    # transpose them into vertical column (which forces to matrix, and character)
    tmpList <- lapply(formatList, function(x) { t(x[param, ,drop=F]) })
    # column bind them together into a matrix
    tmpMat <- do.call(cbind, tmpList)
    colnames(tmpMat) <- names(formatList)
    return(tmpMat)
}

outTable <- paste0("Results",datenow,filttext,"_formatted.txt")
cat("Immune Gene Paired-Control Results\n", file = outTable)
if(usefilter) {cat(paste("Filtered for dN/dS & pN/pS below", maxval), file = outTable, append=T)}

for(myPar in rownames.proper) {
    cat("\n\n", myPar, "\n", file = outTable, append = T, sep="")
    outnow <- formatTable(param = myPar)
    write.table(outnow, file = outTable, append = T, quote = F, sep = "\t", col.names = NA)
}

# formatTable() # Just used for testing
```

Here are the test-statistics and associated p-values 
```{r, echo=F}
x<-1
knitr::kable(round(outdataList[[x]], 6), caption = names(outdataList)[x])
x<-2
knitr::kable(round(outdataList[[x]], 6), caption = names(outdataList)[x])
x<-3
knitr::kable(round(outdataList[[x]], 6), caption = names(outdataList)[x])
x<-4
knitr::kable(round(outdataList[[x]], 6), caption = names(outdataList)[x])
x<-5
knitr::kable(round(outdataList[[x]], 6), caption = names(outdataList)[x])
```

Going to skip running this code and making plots now, because they just show the test statistic relative to the null distribution. But that isn't very informative, given we have the p-values in tables.
```{r, fig.height=10, eval=F}
par(mfrow = c(4,3), bg="grey90", oma=c(1,1,5,1))
for (class in names(permuteValues)) {
	for(stat in names(imGeneValues[[1]][1:12])) {
		xrange <- range( c(permuteValues[[class]][[stat]],imGeneValues[[class]][[stat]]), na.rm = T)
		xrange <- xrange + (diff(xrange) * c(-.1, .1)) # buffer range
		hist(permuteValues[[class]][[stat]], xlab = class, main = stat, breaks = 30, xlim = xrange, col = "light blue", border = "light blue")	
		abline(v = imGeneValues[[class]][[stat]], col = "red")
	}
    mtext(text = class, outer = T)
}

```


Now to visualize immune gene values along with mean control data, with raw values and boxplot distributions. At this point we need to find a way to organize target value and mean-control values for plotting. Trying to do this in a way that makes "tidy" data for ggplot.

```{r}
getPairedVals <- function(imGene, ctlList = contFilt, statDF = genestats, selectCols = NULL, permute = FALSE ) {
	# use `selectCols` to determine which columns should be returned, consistent with func1_means()
	if (is.null(selectCols)) {
		selectCols <- unlist(lapply(statDF, is.numeric))
	}
	
	if (permute) { 
		geneset <- sample(c(imGene,ctlList[[imGene]])) # permute immune gene w/ controls
		target <- geneset[1] # define random "target"
		ctls <- geneset[-1] # define random "controls"
	} else {  # use unpermuted data values
		target <- imGene
		ctls   <- ctlList[[imGene]]
	} 
	target_vals <- unlist(statDF[ statDF$Gene_ID == target,selectCols])  # select values for target gene, need `unlist()` because it is a row, so is not vector
	ctl_vals <- func1_means( refgenes = ctls, statDF = statDF, selectCols = selectCols) # calc mean values for control
	outframe <- data.frame(rbind("immune" = target_vals, "ctlmean" = ctl_vals))
	return(cbind(outframe, "Type" = factor(c("immune","ctlmean"), levels = c("immune","ctlmean")), "gene" = imGene))

}


pairedValsList <- vector(mode = "list", length = length(imGeneValues))
names(pairedValsList) <- names(imGeneClassList)

# make a list of dataframes of immune and mean-control values.
for (i in names(pairedValsList)) {
	tmplist <- lapply(imGeneClassList[[i]], function(x) {getPairedVals(imGene = x) })
	#names(pairedValsList[[i]]) <- imGeneClassList[[i]]
	pairedValsList[[i]] <- do.call(rbind, tmplist)
}


# "melt" the list into a single dataframe with "class" as a factor
library(plyr)
pairedValsDF <- ldply(pairedValsList)
names(pairedValsDF)[1] <- "class"
pairedValsDF$class <- factor(pairedValsDF$class, levels = c("All Immune", "Recognition", "Modulation", "Signaling", "Effector") )
```

With this data structure, we can now use ggplot for visualization

```{r, fig.align='center', fig.width=10, fig.height=10 }

library(ggplot2)
library(gridExtra)

# function to made paired-boxplot with datapoints.
plotdata <- function( myDF = pairedValsDF, stat =  "Pi_gene_0d", ylab = "pi", title = "0-fold" , dsize = 1) { 
	bw <- diff(range(na.omit(myDF[[stat]]))) / 100
	p <- ggplot(data = myDF, aes_string(x="class", y = stat, fill = "Type" )) + 
	geom_dotplot(binaxis = 'y', stackdir='center', position = position_dodge(.75), binwidth = bw, dotsize = dsize) + 
	geom_boxplot( alpha = 0.5, outlier.shape = NA) + ylab(ylab) + xlab(NULL) + ggtitle(title) + theme_light() + theme(legend.position="none")
	return(p)
	}


# Preparing indexing and labels for plotting
statNames <- names(imGeneValues[[1]])[c(1,3,2,4,6,5,7,9,8,11,12,10,13,14)] # rearrage order to: Pi, Theta, TajD
statLabels <- c("Pi 0x", "Theta 0x","Tajima's D 0x", "Pi 4x", "Theta 4x","Tajima's D 4x", "Pi gene", "Theta gene","Tajima's D gene", "dN/dS", "Pi_N/Pi_S", "Direction of Selection","Alpha", "Omega_Alpha")
polylabs <- c("Pi", "Theta","Tajima's D")

# Plot polymorphism statistics 
polyplots <- lapply(1:9, function(i) {plotdata(stat = statNames[i], ylab = c(polylabs,polylabs,polylabs)[i], title = statLabels[i])})
grid.arrange(grobs = polyplots)
# also write out files
outfile <- paste0("poly_plots",datenow,filttext,".pdf")
ggsave(filename = outfile, plot = grid.arrange(grobs = polyplots), w = 8, h = 8, units = "in", scale = 2)
```

**Dec 23, 2020:** This next code block reflect an early attempt to format plots for figures to be included in manuscript. I'm leaving it here for reference, but the effort evolved beyond this with the use of `ggpubr` package.
```{r, eval = F}

# Adding plots for manuscript.
polyplots.ms <- lapply(c(1,4,2,5,3,6), function(i) {plotdata(myDF = pairedValsDF[pairedValsDF$class != "All Immune", ], stat = statNames[i], ylab = c(polylabs,polylabs,polylabs)[i], title = statLabels[i], dsize = 2)  })
#grid.arrange(grobs = polyplots.ms,ncol = 2)
outfile <- paste0("poly_plots-MS",datenow,filttext,".pdf")
ggsave(filename = outfile, plot = grid.arrange(grobs = polyplots.ms, ncol = 2), w = 6, h = 4, units = "in", scale = 2)



# Plot divergence statistics 
divplots <- lapply(10:14, function(i) {plotdata(stat = statNames[i], ylab = statLabels[i], title = statLabels[i])})
grid.arrange(grobs = divplots)
#also write out to file
outfile <- paste0("div_plots",datenow,filttext,".pdf")
ggsave(filename = outfile, plot = grid.arrange(grobs = divplots), w = 8, h = 8, units = "in", scale = 1.5)
```


**Dec 23, 2020:** This next code block is the current version of making plots for the manuscript.  There are four plots here:  

1. Fig 1: 0x & 4x polymorphism data, excluding "All Genes" combined
2. Supplemental 1: polymorphism data, including "All Genes" combined, for 0x, 4x, and the "whole" gene.
3. Fig 2: dN/dS and pN/pS, excluding "All Genes" combined
4. Supplemental 2:  dN/dS, pN/pS, DoS, alpha, W~a~, including "All Genes".


```{r}
library(ggpubr)
### Slightly simplified plotting function for later customization
plotdata.simple <- function( myDF = pairedValsDF, stat =  "Pi_gene_0d", ylab = "pi", title = "0-fold" , dsize = 1) { 
    bw <- diff(range(na.omit(myDF[[stat]]))) / 100
    p <- ggplot(data = myDF, aes_string(x="class", y = stat, fill = "Type" )) + 
        geom_dotplot(binaxis = 'y', stackdir='center', position = position_dodge(.75), binwidth = bw, dotsize = dsize) + 
        geom_boxplot( alpha = 0.5, outlier.shape = NA) + xlab(NULL) +
        scale_fill_discrete(labels = c("Immune", "Mean(control)"))
    return(p)
}

### Making main plot for polymorphism
polyplots.ms <- lapply(c(1,4,2,5,3,6), function(i) {plotdata.simple(myDF = pairedValsDF[pairedValsDF$class != "All Immune", ], stat = statNames[i], ylab = c(polylabs,polylabs,polylabs)[i], title = statLabels[i], dsize = 2) + theme_light()  })

# remove x-axis categories for top 4 plots
polyplots.ms[1:4] <- lapply(polyplots.ms[1:4], function(x) {return(x + theme(axis.text.x = element_blank() ) )})

# enhance X-axis labels
polyplots.ms[5:6] <- lapply(polyplots.ms[5:6], function(x) {return(x + theme(axis.text.x =element_text(face = "bold") ) )}) # angle=45, hjust = 1

# add titles to top 2 plots
polyplots.ms[[1]] <- polyplots.ms[[1]] + ggtitle("0-fold degenerate")
polyplots.ms[[2]] <- polyplots.ms[[2]] + ggtitle("4-fold degenerate")

# remove y axis labels for "right hand" plots
polyplots.ms[-c(1,3,5)] <- lapply(polyplots.ms[-c(1,3,5)], function(x) {return(x + ylab(NULL) )})

polyplots.ms[[1]] <- polyplots.ms[[1]] + ylab(expression(paste("Nuc Diversity (",pi,")")))
polyplots.ms[[3]] <- polyplots.ms[[3]] + ylab(expression(paste("Watterson's ",theta)))
polyplots.ms[[5]] <- polyplots.ms[[5]] + ylab("Tajima's D")

out.arrange <- ggarrange(plotlist = polyplots.ms, common.legend = T, ncol = 2, nrow = 3, legend = "bottom", align = "v")

print(out.arrange) # plot in markdown

outfile <- paste0("poly_plots-MS",datenow,filttext,".pdf")
ggsave(filename = outfile, plot = out.arrange, w = 6, h = 4, units = "in", scale = 2)



### Replicate for supplement, but include ALL GENES category and also data for "full gene" 
polyplots.supp <- lapply(c(1,4,7,2,5,8,3,6,9), function(i) {plotdata.simple(myDF = pairedValsDF, stat = statNames[i], ylab = c(polylabs,polylabs,polylabs)[i], title = statLabels[i], dsize = 1) + theme_light()  })

# remove x-axis categories for top 6 plots
polyplots.supp[1:6] <- lapply(polyplots.supp[1:6], function(x) {return(x + theme(axis.text.x = element_blank() ) )})

# enhance X-axis labels
polyplots.supp[7:9] <- lapply(polyplots.supp[7:9], function(x) {return(x + theme(axis.text.x =element_text(face = "bold") ) )}) # angle=45, hjust = 1

# add titles to top 3 plots
polyplots.supp[[1]] <- polyplots.supp[[1]] + ggtitle("0-fold degenerate")
polyplots.supp[[2]] <- polyplots.supp[[2]] + ggtitle("4-fold degenerate")
polyplots.supp[[3]] <- polyplots.supp[[3]] + ggtitle("All sites")

# remove y-axis labels from all but left-hand plots
polyplots.supp[-c(1,4,7)] <- lapply(polyplots.supp[-c(1,4,7)], function(x) {return(x + ylab(NULL) )})

polyplots.supp[[1]] <- polyplots.supp[[1]] + ylab(expression(paste("Nuc Diversity (",pi,")")))
polyplots.supp[[4]] <- polyplots.supp[[4]] + ylab(expression(paste("Watterson's ",theta)))
polyplots.supp[[7]] <- polyplots.supp[[7]] + ylab("Tajima's D")

out.arrange.supp <- ggarrange(plotlist = polyplots.supp, common.legend = T, ncol = 3, nrow = 3, legend = "bottom", align = "v")
print(out.arrange.supp)

#grid.arrange(grobs = polyplots.ms,ncol = 2)
outfile <- paste0("poly_plots-SUPP",datenow,filttext,".pdf")
ggsave(filename = outfile, plot = out.arrange.supp, w = 8, h = 6, units = "in", scale = 2)




###  Plot dN/dS and pN/pS for main manuscript. 
divplots.ms <- lapply(c(10:11), function(i) {plotdata.simple(myDF = pairedValsDF[pairedValsDF$class != "All Immune", ], stat = statNames[i], ylab = c(polylabs,polylabs,polylabs)[i], title = statLabels[i], dsize = 2) + theme_light()  })

# enhance X-axis labels
divplots.ms <- lapply(divplots.ms, function(x) {return(x + theme(axis.text.x =element_text(face = "bold") ) )}) # angle=45, hjust = 1

# add titles to top 2 plots
divplots.ms[[1]] <- divplots.ms[[1]] + ggtitle("Divergence Rate Ratio")
divplots.ms[[2]] <- divplots.ms[[2]] + ggtitle("Polymorphism Rate Ratio")

divplots.ms[[1]] <- divplots.ms[[1]] + ylab("dN/dS")
divplots.ms[[2]] <- divplots.ms[[2]] + ylab("pN/pS")

div.arrange <- ggarrange(plotlist = divplots.ms, common.legend = T, ncol = 2, nrow = 1, legend = "bottom", align = "v")
print(div.arrange)

outfile <- paste0("Div_plots-MS",datenow,filttext,".pdf")
ggsave(filename = outfile, plot = div.arrange, w = 6, h = 2, units = "in", scale = 2)




###  Plot all 5 divergence stats for main supplement, including all genes 
divplots.supp <- lapply(c(10:14), function(i) {plotdata.simple(myDF = pairedValsDF, stat = statNames[i], ylab = c(polylabs,polylabs,polylabs)[i], title = statLabels[i], dsize = 1.3) + theme_light()  })

# remove x-axis categories for first 3 plots
divplots.supp[1:3] <- lapply(divplots.supp[1:3], function(x) {return(x + theme(axis.text.x = element_blank() ) )})

# enhance X-axis labels
divplots.supp <- lapply(divplots.supp, function(x) {return(x + theme(axis.text.x =element_text(face = "bold") ) )}) # angle=45, hjust = 1

# add titles to plots
divplots.supp[[1]] <- divplots.supp[[1]] + ggtitle("Divergence Rate Ratio")
divplots.supp[[2]] <- divplots.supp[[2]] + ggtitle("Polymorphism Rate Ratio")
divplots.supp[[3]] <- divplots.supp[[3]] + ggtitle("Direction of Selection")
divplots.supp[[4]] <- divplots.supp[[4]] + ggtitle("Adaptive Substitutions: Proportion")
divplots.supp[[5]] <- divplots.supp[[5]] + ggtitle("Adaptive Substitutions: Rate")

# divplots.supp[-c(1,3,5)] <- lapply(divplots.supp[-c(1,3,5)], function(x) {return(x + ylab(NULL) )})

divplots.supp[[1]] <- divplots.supp[[1]] + ylab("dN/dS")
divplots.supp[[2]] <- divplots.supp[[2]] + ylab("pN/pS")
divplots.supp[[3]] <- divplots.supp[[3]] + ylab("DoS")
divplots.supp[[4]] <- divplots.supp[[4]] + ylab(expression(paste(alpha)))
divplots.supp[[5]] <- divplots.supp[[5]] + ylab(expression(paste(omega[alpha])))
#ylab(expression(paste("Nuc Diversity (",pi,")")))

div.arrange.supp <- ggarrange(plotlist = divplots.supp, common.legend = T, ncol = 2, nrow = 3, legend = "bottom", align = "v")
print(div.arrange.supp)

outfile <- paste0("Div_plots-SUPP",datenow,filttext,".pdf")
ggsave(filename = outfile, plot = div.arrange.supp, w = 8, h = 6, units = "in", scale = 2)
```




Now plotting each class by itself, for individual reference. 

**Dec 23, 2020:** Not executing this code block to save space. Individual outputs not really necessary at this point.
```{r, fig.align='center', fig.height=8, fig.width=5, eval=F}

# Plotting stats individually for each class of gene
classPlots <- vector(mode = "list", length = length(imGeneValues))
names(classPlots) <- names(imGeneValues)
#pdf(file = "Stats_by_Class-FILTERED.pdf", h=10, w=5, pointsize = 9)
for (class in names(imGeneValues)) {
	classPlots[[class]] <- lapply(1:9, function(i) {plotdata(myDF = pairedValsDF[pairedValsDF$class == class, ], stat = statNames[i], ylab = statLabels[i], title = statLabels[i])}) 
	grid.arrange(grobs=classPlots[[class]], ncol = 3, top = class)
	
		classPlots[[class]] <- lapply(10:14, function(i) {plotdata(myDF = pairedValsDF[pairedValsDF$class == class, ], stat = statNames[i], ylab = statLabels[i], title = statLabels[i])}) 
	grid.arrange(grobs=classPlots[[class]], ncol = 2, top = class)
}
#dev.off()
```

